# å•ä¸ªæ–‡ä»¶çš„å®Œæ•´å¤„ç†æµç¨‹

## â—é‡è¦è¯´æ˜

**Oxlint ä¸æ˜¯ç›´æ¥è¯»å–æ–‡ä»¶å°±èƒ½æ£€æŸ¥çš„ï¼** å¿…é¡»ç»è¿‡ä»¥ä¸‹å®Œæ•´æµç¨‹ï¼š

```
è¯»å–æ–‡ä»¶ â†’ è§£ææˆ AST â†’ è¯­ä¹‰åˆ†æ â†’ æ‰§è¡Œ Lint è§„åˆ™ â†’ è¾“å‡ºè¯Šæ–­
```

---

## ğŸ”¥ å®Œæ•´å¤„ç†æµç¨‹

### é˜¶æ®µ 1: è¯»å–æ–‡ä»¶å†…å®¹

**ä½ç½®**: `crates/oxc_linter/src/service/runtime.rs:341`

```rust
// è¯»å–æ–‡ä»¶åˆ° arena å†…å­˜åˆ†é…å™¨ä¸­
let file_result = self.file_system.read_to_arena_str(path, allocator)
```

**è¾“å‡º**:

- `source_text: &str` - æ–‡ä»¶çš„åŸå§‹æ–‡æœ¬å†…å®¹
- `source_type: SourceType` - æ–‡ä»¶ç±»å‹ï¼ˆJS/TS/JSX/TSX ç­‰ï¼‰

---

### é˜¶æ®µ 2: ğŸ”¥ è§£ææˆ ASTï¼ˆAbstract Syntax Treeï¼‰

**ä½ç½®**: `crates/oxc_linter/src/service/runtime.rs:966-972`

```rust
// ä½¿ç”¨ oxc_parser å°†æºä»£ç è§£ææˆ AST
let ret = Parser::new(allocator, source_text, source_type)
    .with_options(ParseOptions {
        parse_regular_expression: true,        // è§£ææ­£åˆ™è¡¨è¾¾å¼
        allow_return_outside_function: true,   // å…è®¸å‡½æ•°å¤–çš„ return
        ..ParseOptions::default()
    })
    .parse();  // ğŸ”¥ è¿™é‡Œæ‰§è¡Œè§£æï¼

// æ£€æŸ¥è§£æé”™è¯¯
if !ret.errors.is_empty() {
    return Err(ret.errors);  // æœ‰è¯­æ³•é”™è¯¯ï¼Œç›´æ¥è¿”å›
}
```

**å…³é”®ç‚¹**:

- ä½¿ç”¨ **oxc_parser** crate è¿›è¡Œè§£æ
- å°†æºä»£ç å­—ç¬¦ä¸²è½¬æ¢ä¸º **AST æ•°æ®ç»“æ„**
- AST åŒ…å«ç¨‹åºçš„å®Œæ•´ç»“æ„ä¿¡æ¯ï¼ˆè¡¨è¾¾å¼ã€è¯­å¥ã€å£°æ˜ç­‰ï¼‰
- å¦‚æœæœ‰è¯­æ³•é”™è¯¯ï¼Œç›´æ¥æŠ¥é”™ï¼Œä¸ç»§ç»­å¤„ç†

**è¾“å‡º**:

- `ret.program: Program` - AST æ ¹èŠ‚ç‚¹
- `ret.errors` - è§£æé”™è¯¯åˆ—è¡¨
- `ret.module_record` - æ¨¡å—å¯¼å…¥å¯¼å‡ºä¿¡æ¯

---

### é˜¶æ®µ 3: ğŸ”¥ è¯­ä¹‰åˆ†æï¼ˆSemantic Analysisï¼‰

**ä½ç½®**: `crates/oxc_linter/src/service/runtime.rs:978-990`

```rust
// ä½¿ç”¨ oxc_semantic è¿›è¡Œè¯­ä¹‰åˆ†æ
let semantic_ret = SemanticBuilder::new()
    .with_cfg(true)                      // æ„å»ºæ§åˆ¶æµå›¾ (Control Flow Graph)
    .with_scope_tree_child_ids(true)     // æ„å»ºä½œç”¨åŸŸæ ‘
    .with_build_jsdoc(true)              // è§£æ JSDoc æ³¨é‡Š
    .with_check_syntax_error(check_syntax_errors)
    .build(allocator.alloc(ret.program)); // ğŸ”¥ è¿™é‡Œæ‰§è¡Œè¯­ä¹‰åˆ†æï¼

// æ£€æŸ¥è¯­ä¹‰é”™è¯¯
if !semantic_ret.errors.is_empty() {
    return Err(semantic_ret.errors);
}

let mut semantic = semantic_ret.semantic;
semantic.set_irregular_whitespaces(ret.irregular_whitespaces);
```

**å…³é”®ç‚¹**:

- ä½¿ç”¨ **oxc_semantic** crate è¿›è¡Œè¯­ä¹‰åˆ†æ
- åœ¨ AST çš„åŸºç¡€ä¸Šæ„å»ºæ›´å¤šä¿¡æ¯ï¼š
  - **ç¬¦å·è¡¨** (Symbol Table) - å˜é‡ã€å‡½æ•°çš„å®šä¹‰å’Œå¼•ç”¨
  - **ä½œç”¨åŸŸæ ‘** (Scope Tree) - åµŒå¥—çš„ä½œç”¨åŸŸå…³ç³»
  - **æ§åˆ¶æµå›¾** (CFG) - ç¨‹åºæ‰§è¡Œæµ
  - **ç±»å‹ä¿¡æ¯** (Type Info) - TypeScript ç±»å‹ï¼ˆå¦‚æœæ˜¯ TSï¼‰
  - **å¼•ç”¨å…³ç³»** - å˜é‡çš„è¯»å†™å…³ç³»

**è¾“å‡º**:

- `semantic: Semantic` - åŒ…å«æ‰€æœ‰è¯­ä¹‰ä¿¡æ¯çš„ç»“æ„

---

### é˜¶æ®µ 4: å‡†å¤‡ Lint ä¸Šä¸‹æ–‡

**ä½ç½®**: `crates/oxc_linter/src/service/runtime.rs:600-650`

```rust
// ä¸ºæ¯ä¸ªè„šæœ¬å—åˆ›å»ºä¸Šä¸‹æ–‡
let context_sub_hosts: Vec<ContextSubHost> = section_module_records
    .into_iter()
    .zip(dep.section_contents)
    .map(|(module_record, content)| {
        ContextSubHost::new(
            Arc::clone(module_record),
            content.semantic,  // ä¼ å…¥è¯­ä¹‰åˆ†æç»“æœ
        )
    })
    .collect();
```

**å…³é”®ç‚¹**:

- å°†è¯­ä¹‰åˆ†æç»“æœåŒ…è£…æˆ `ContextSubHost`
- ä¸€ä¸ªæ–‡ä»¶å¯èƒ½æœ‰å¤šä¸ªè„šæœ¬å—ï¼ˆä¾‹å¦‚ Vue/Svelte æ–‡ä»¶ï¼‰
- æ¯ä¸ªè„šæœ¬å—éƒ½æœ‰ç‹¬ç«‹çš„ä¸Šä¸‹æ–‡

---

### é˜¶æ®µ 5: ğŸ”¥ğŸ”¥ğŸ”¥ æ‰§è¡Œ Lint è§„åˆ™

**ä½ç½®**: `crates/oxc_linter/src/service/runtime.rs:654-656`

```rust
// è°ƒç”¨ Linter.run() æ‰§è¡Œæ‰€æœ‰è§„åˆ™
let lint_result = me.linter.run(path, context_sub_hosts, allocator_guard);
```

**è¿›å…¥ Linter::run()** (`crates/oxc_linter/src/lib.rs:130-383`)

```rust
pub fn run<'a>(
    &self,
    path: &Path,
    context_sub_hosts: Vec<ContextSubHost<'a>>,
    allocator: &'a Allocator,
) -> Vec<Message<'a>> {
    // 1. åˆ›å»ºä¸Šä¸‹æ–‡å®¿ä¸»
    let ctx_host = Rc::new(ContextHost::new(path, context_sub_hosts, ...));

    loop {
        // 2. è¿‡æ»¤é€‚ç”¨çš„è§„åˆ™
        let rules = rules
            .iter()
            .filter(|(rule, _)| rule.should_run(&ctx_host))
            .map(|(rule, severity)| (rule, ctx_host.spawn(rule, *severity)))
            .collect::<Vec<_>>();

        let semantic = ctx_host.semantic();  // è·å–è¯­ä¹‰åˆ†æç»“æœ

        // 3. æ‰§è¡Œè§„åˆ™
        for (rule, ctx) in &rules {
            // æ‰§è¡Œä¸€æ¬¡æ€§æ£€æŸ¥
            rule.run_once(ctx);

            // ğŸ”¥ éå† AST èŠ‚ç‚¹ï¼Œå¯¹æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œè§„åˆ™
            for node in semantic.nodes() {  // è¿™é‡Œéå†çš„æ˜¯ AST èŠ‚ç‚¹ï¼
                rule.run(node, ctx);
            }
        }

        // 4. æ£€æŸ¥æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªè„šæœ¬å—
        if !ctx_host.next_sub_host() {
            break;
        }
    }

    // 5. è¿”å›è¯Šæ–­ç»“æœ
    ctx_host.take_diagnostics()
}
```

**å…³é”®ç‚¹**:

- è§„åˆ™æ˜¯åŸºäº **AST èŠ‚ç‚¹** æ‰§è¡Œçš„
- æ¯ä¸ªè§„åˆ™å®ç° `run(node, ctx)` æ–¹æ³•
- è§„åˆ™é€šè¿‡æ£€æŸ¥èŠ‚ç‚¹ç±»å‹å’Œå±æ€§æ¥å‘ç°é—®é¢˜
- ä¾‹å¦‚ï¼šæ£€æŸ¥ `VariableDeclaration` èŠ‚ç‚¹çš„ `kind` æ˜¯å¦ä¸º `var`

---

## ğŸ“Š å®Œæ•´æµç¨‹å›¾

```mermaid
flowchart TD
    Start([å¼€å§‹å¤„ç†æ–‡ä»¶]) --> DetectType[æ£€æµ‹æ–‡ä»¶ç±»å‹<br/>JS/TS/JSX/TSX]
    DetectType --> CreateAllocator[åˆ›å»º Arena åˆ†é…å™¨<br/>Allocator]
    CreateAllocator --> ReadFile[è¯»å–æ–‡ä»¶å†…å®¹<br/>source_text: &str]

    ReadFile --> Parse[ğŸ”¥ æ­¥éª¤ 1: è§£æ AST<br/>oxc_parser::Parser.parse]

    Parse --> ParseSuccess{è§£æ<br/>æˆåŠŸ?}
    ParseSuccess -->|å¤±è´¥| ParseError[æŠ¥å‘Šè¯­æ³•é”™è¯¯]
    ParseError --> SendError[å‘é€é”™è¯¯åˆ°ä¸»çº¿ç¨‹]
    SendError --> End([å¤„ç†å®Œæˆ])

    ParseSuccess -->|æˆåŠŸ| GetAST[è·å¾— AST<br/>Program æ ¹èŠ‚ç‚¹]

    GetAST --> Semantic[ğŸ”¥ æ­¥éª¤ 2: è¯­ä¹‰åˆ†æ<br/>oxc_semantic::SemanticBuilder.build]

    Semantic --> BuildSymbols[æ„å»ºç¬¦å·è¡¨<br/>Symbol Table]
    BuildSymbols --> BuildScopes[æ„å»ºä½œç”¨åŸŸæ ‘<br/>Scope Tree]
    BuildScopes --> BuildCFG[æ„å»ºæ§åˆ¶æµå›¾<br/>Control Flow Graph]
    BuildCFG --> BuildRefs[æ„å»ºå¼•ç”¨å…³ç³»<br/>References]

    BuildRefs --> SemanticSuccess{è¯­ä¹‰åˆ†æ<br/>æˆåŠŸ?}
    SemanticSuccess -->|å¤±è´¥| SemanticError[æŠ¥å‘Šè¯­ä¹‰é”™è¯¯]
    SemanticError --> SendError

    SemanticSuccess -->|æˆåŠŸ| CreateContext[åˆ›å»º Lint ä¸Šä¸‹æ–‡<br/>ContextSubHost]

    CreateContext --> CallLinter[ğŸ”¥ æ­¥éª¤ 3: è°ƒç”¨ Linter.run]

    CallLinter --> FilterRules[è¿‡æ»¤é€‚ç”¨çš„è§„åˆ™]
    FilterRules --> RunOnce[æ‰§è¡Œ rule.run_once]
    RunOnce --> IterateNodes[éå†æ‰€æœ‰ AST èŠ‚ç‚¹]

    IterateNodes --> CheckNode{å½“å‰èŠ‚ç‚¹}
    CheckNode --> |VariableDeclaration| CheckVar[æ£€æŸ¥å˜é‡å£°æ˜]
    CheckNode --> |FunctionDeclaration| CheckFunc[æ£€æŸ¥å‡½æ•°å£°æ˜]
    CheckNode --> |IfStatement| CheckIf[æ£€æŸ¥æ¡ä»¶è¯­å¥]
    CheckNode --> |å…¶ä»–èŠ‚ç‚¹ç±»å‹| CheckOther[æ£€æŸ¥å…¶ä»–è§„åˆ™]

    CheckVar --> RunRules[è¿è¡Œç›¸å…³è§„åˆ™]
    CheckFunc --> RunRules
    CheckIf --> RunRules
    CheckOther --> RunRules

    RunRules --> CollectDiag[æ”¶é›†è¯Šæ–­ä¿¡æ¯]
    CollectDiag --> MoreNodes{è¿˜æœ‰<br/>èŠ‚ç‚¹?}

    MoreNodes -->|æ˜¯| IterateNodes
    MoreNodes -->|å¦| CheckFix{å¯ç”¨<br/>è‡ªåŠ¨ä¿®å¤?}

    CheckFix -->|æ˜¯| ApplyFixes[åº”ç”¨ä¿®å¤<br/>ä¿®æ”¹ AST]
    CheckFix -->|å¦| SendDiagnostics[å‘é€è¯Šæ–­ä¿¡æ¯]

    ApplyFixes --> Codegen[ä»£ç ç”Ÿæˆ<br/>oxc_codegen]
    Codegen --> WriteBack[å†™å›æ–‡ä»¶]
    WriteBack --> SendDiagnostics

    SendDiagnostics --> End

    style Parse fill:#ff9999
    style Semantic fill:#ff9999
    style CallLinter fill:#ff9999
    style IterateNodes fill:#ffff99
```

---

## ğŸ” ä¸ºä»€ä¹ˆå¿…é¡»è¦ ASTï¼Ÿ

### 1. **ç†è§£ä»£ç ç»“æ„**

åŸå§‹æ–‡æœ¬ï¼š

```javascript
const x = 1 + 2;
```

AST è¡¨ç¤ºï¼š

```json
{
  "type": "VariableDeclaration",
  "kind": "const",
  "declarations": [{
    "id": { "type": "Identifier", "name": "x" },
    "init": {
      "type": "BinaryExpression",
      "operator": "+",
      "left": { "type": "NumericLiteral", "value": 1 },
      "right": { "type": "NumericLiteral", "value": 2 }
    }
  }]
}
```

**æœ‰äº† ASTï¼Œè§„åˆ™æ‰èƒ½**ï¼š

- åˆ¤æ–­è¿™æ˜¯ä¸€ä¸ªå˜é‡å£°æ˜
- çŸ¥é“ä½¿ç”¨çš„æ˜¯ `const` è€Œä¸æ˜¯ `var`
- ç†è§£åˆå§‹åŒ–å€¼æ˜¯ä¸€ä¸ªäºŒå…ƒè¡¨è¾¾å¼
- æ£€æŸ¥æ“ä½œç¬¦å’Œæ“ä½œæ•°

### 2. **è®¿é—®è€…æ¨¡å¼ï¼ˆVisitor Patternï¼‰**

Lint è§„åˆ™é€šè¿‡è®¿é—®è€…æ¨¡å¼éå† ASTï¼š

```rust
// è§„åˆ™ç¤ºä¾‹ï¼šç¦æ­¢ä½¿ç”¨ var
impl Rule for NoVar {
    fn run(&self, node: &AstNode, ctx: &LintContext) {
        // åªå¯¹ VariableDeclaration èŠ‚ç‚¹æ„Ÿå…´è¶£
        if let AstKind::VariableDeclaration(decl) = node.kind() {
            // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº† var
            if decl.kind == VariableDeclarationKind::Var {
                ctx.diagnostic(no_var_diagnostic(node.span()));
            }
        }
    }
}
```

### 3. **è¯­ä¹‰ä¿¡æ¯å¿…ä¸å¯å°‘**

è®¸å¤šè§„åˆ™éœ€è¦è¯­ä¹‰åˆ†ææä¾›çš„ä¿¡æ¯ï¼š

```javascript
function test() {
  console.log(x); // âŒ 'x' is not defined
  var x = 1; // âœ… å˜é‡æå‡
}
```

**éœ€è¦è¯­ä¹‰åˆ†ææ‰èƒ½åˆ¤æ–­**ï¼š

- å˜é‡æ˜¯å¦å·²å£°æ˜
- ä½œç”¨åŸŸå…³ç³»
- å˜é‡çš„è¯»å†™
- æ˜¯å¦æœ‰æœªä½¿ç”¨çš„å˜é‡
- æ˜¯å¦æœ‰å¾ªç¯å¼•ç”¨

---

## ğŸ¯ å…³é”®ç»„ä»¶èŒè´£

| ç»„ä»¶             | è¾“å…¥       | è¾“å‡º     | èŒè´£                |
| ---------------- | ---------- | -------- | ------------------- |
| **FileSystem**   | æ–‡ä»¶è·¯å¾„   | æ–‡æœ¬å†…å®¹ | è¯»å–æ–‡ä»¶            |
| **oxc_parser**   | æ–‡æœ¬å†…å®¹   | AST      | è¯æ³•+è¯­æ³•åˆ†æ       |
| **oxc_semantic** | AST        | è¯­ä¹‰ä¿¡æ¯ | ç¬¦å·è¡¨ã€ä½œç”¨åŸŸã€CFG |
| **Linter**       | AST + è¯­ä¹‰ | è¯Šæ–­ä¿¡æ¯ | æ‰§è¡Œè§„åˆ™æ£€æŸ¥        |
| **oxc_codegen**  | AST        | æ–‡æœ¬å†…å®¹ | ä»£ç ç”Ÿæˆï¼ˆä¿®å¤æ—¶ï¼‰  |

---

## ğŸ’¡ æ€§èƒ½ä¼˜åŒ–ç‚¹

### 1. **é›¶æ‹·è´è§£æ**

```rust
// ä½¿ç”¨ arena åˆ†é…å™¨ï¼Œé¿å…é¢‘ç¹çš„å†…å­˜åˆ†é…
let allocator = Allocator::default();
let source_text = file_system.read_to_arena_str(path, &allocator);
```

### 2. **å¹¶è¡Œå¤„ç†**

```rust
// æ¯ä¸ªæ–‡ä»¶ç‹¬ç«‹å¤„ç†ï¼Œå¯ä»¥å¹¶è¡Œ
paths.par_iter().for_each(|path| {
    // ç‹¬ç«‹çš„ allocator
    let allocator = Allocator::default();
    // è§£æ â†’ è¯­ä¹‰åˆ†æ â†’ lint
});
```

### 3. **æŒ‰éœ€è§£æ**

```rust
// åªè§£æéœ€è¦çš„éƒ¨åˆ†
ParseOptions {
    parse_regular_expression: true,  // æŸäº›è§„åˆ™éœ€è¦
    ..ParseOptions::default()
}
```

### 4. **æ™ºèƒ½ç¼“å­˜**

- å°æ–‡ä»¶ï¼šèŠ‚ç‚¹æ•°æ®ä¿ç•™åœ¨ CPU ç¼“å­˜
- å¤§æ–‡ä»¶ï¼šè§„åˆ™æ•°æ®ä¿ç•™åœ¨ CPU ç¼“å­˜

---

## ğŸ“ æ€»ç»“

**Oxlint çš„å®Œæ•´å¤„ç†é“¾**ï¼š

```
æ–‡ä»¶è·¯å¾„
  â†“ (read_to_arena_str)
åŸå§‹æ–‡æœ¬
  â†“ (oxc_parser::Parser)
AST (æŠ½è±¡è¯­æ³•æ ‘)
  â†“ (oxc_semantic::SemanticBuilder)
è¯­ä¹‰ä¿¡æ¯ (ç¬¦å·è¡¨ã€ä½œç”¨åŸŸã€CFG)
  â†“ (Linter::run)
éå† AST èŠ‚ç‚¹ï¼Œæ‰§è¡Œè§„åˆ™
  â†“
è¯Šæ–­ç»“æœ
  â†“ (å¯é€‰ï¼šoxc_codegen)
ä¿®å¤åçš„ä»£ç 
```

**æ²¡æœ‰ AST å°±æ— æ³• Lintï¼** æ‰€æœ‰çš„é™æ€åˆ†æå·¥å…·ï¼ˆESLintã€Prettierã€TypeScript Compiler ç­‰ï¼‰éƒ½ä¾èµ–äº ASTã€‚
